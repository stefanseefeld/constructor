

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Advanced concepts - Faber 1.0 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.0',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="Faber 1.0 documentation" href="../index.html" />
    <link rel="up" title="Faber Tutorial" href="index.html" />
    <link rel="next" title="Special Topics" href="special_topics.html" />
    <link rel="prev" title="Basic concepts" href="basic_concepts.html" /> 
  </head>
  <body>
    <div class="header">
    <table border="0" cellpadding="7" cellspacing="0" width="100%" summary=
    "header">
      <tr>
        <td valign="top" width="300">
          <h3><a href="../index.html"><img 
          alt="C++ Boost" src="../_static/logo.png" border="0"></a></h3>
        </td>
	<td>
      <div id="searchbox" style="display: none">
        <form class="search" action="../search.html" method="get">
          <input type="text" name="q" size="18" />
          <input type="submit" value="Search" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
      </div>
      <script type="text/javascript">$('#searchbox').show(0);</script>
	</td>
      </tr>
    </table>
    </div>
    <hr/>
    <div class="content">
    <div class="navbar" style="text-align:right;">
      
      
      <a class="prev" title="Basic concepts" href="basic_concepts.html"><img src="../_static/prev.png" alt="prev"/></a>
      <a class="up" title="Faber Tutorial" href="index.html"><img src="../_static/up.png" alt="up"/></a>
      <a class="next" title="Special Topics" href="special_topics.html"><img src="../_static/next.png" alt="next"/></a>
      
    </div>
      
  <div class="section" id="advanced-concepts">
<h1>Advanced concepts</h1>
<div class="section" id="tools">
<h2>Tools</h2>
<p>Tools provide an object-oriented model around actions. For example, an abstract <cite>compiler</cite>
tool may provide different methods to compile and link code. Concrete compilers may
then provide implementations of that base class, and run the appropriate command for
the respective platform. That substitution can happen during the build process, while
the build logic encoded in the fabscript is strictly platform-agnostic.</p>
<p>Let's augment the original <cite>Hello World !</cite> example to illustrate this. Faber provides
a few built-in tools, such as C and C++ compilers. The abstract interface may look like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">cxx</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="nb">compile</span> <span class="o">=</span> <span class="n">action</span><span class="p">()</span>
    <span class="n">link</span> <span class="o">=</span> <span class="n">action</span><span class="p">()</span>
</pre></div>
</div>
<p>which allows fabscripts to reference <cite>cxx.compile</cite> when defining rules:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">obj</span> <span class="o">=</span> <span class="n">rule</span><span class="p">(</span><span class="n">cxx</span><span class="o">.</span><span class="n">compile</span><span class="p">,</span> <span class="s1">&#39;hello.o&#39;</span><span class="p">,</span> <span class="s1">&#39;hello.cpp&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><cite>faber</cite> also provides specific compilers implementing the above interface, for example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">gxx</span><span class="p">(</span><span class="n">cxx</span><span class="p">):</span>

    <span class="nb">compile</span> <span class="o">=</span> <span class="n">action</span><span class="p">(</span><span class="s1">&#39;g++ -c -o $(&lt;) $(&gt;)&#39;</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>allowing the build system to later substitute <cite>gxx.compile</cite> where <cite>cxx.compile</cite> was
requested. For each reference to an abstract tool, faber will attempt to instantiate
a suitable concrete tool matching the currently active feature set. Thus it's possible
to request a specific compiler on the command line:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ faber cxx.name=gxx
</pre></div>
</div>
<p>Tools may also be instantiated explicitly in a config file, allowing for additional
configuration (such as specific paths or flags):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">gxx11</span> <span class="o">=</span> <span class="n">gxx</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;g++11&#39;</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">cxxflags</span><span class="p">(</span><span class="s1">&#39;--std=c++11&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Here, we defined a new <cite>gxx</cite> instance using an additional flag <cite>==std=c++11</cite>, and
gave it the name <cite>g++11</cite>. To select that from the command line, we would invoke:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ faber cxx.name=g++11
</pre></div>
</div>
<p>You may also want to set up a <cite>gxx</cite> instance to configure a cross-compiler:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>mingwxx = gxx(name=&#39;mingw++&#39;, command=`/usr/bin/x86_64-w64-mingw32-g++`)
</pre></div>
</div>
<p>and then cross-compile by invoking:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ faber cxx.name=mingw++
</pre></div>
</div>
</div>
<div class="section" id="implicit-rules">
<h2>Implicit rules</h2>
<p>While simple build pipelines may be declared using <cite>rules</cite>, this leads to a lot
of repitition as very similar rules would need to be declared to compile all source
files into object files, for example. To simplify this, <cite>implicit rules</cite> can be provided
by tools, which don't declare how to make a specific artefact from a source (or prerequisite
artefact), but rather how a certain artefact <em>type</em> (e.g., an object file) can be generated
from a source (or artefact) type (such as a C or C++ source file).
Higher-order artefacts such as <cite>library</cite> or <cite>binary</cite> can then request that the appropriate
implicit rules are instantiated into ordinary rules to make a library or a binary without
the user having to spell out all the intermediate artefacts.</p>
<p>This is done in a tool's constructor. For example, the <cite>gxx</cite> constructor calls:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">implicit_rule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compile</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">cxx</span><span class="p">)</span>
<span class="n">implicit_rule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">archive</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">lib</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
<span class="n">implicit_rule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">bin</span><span class="p">,</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">dso</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">lib</span><span class="p">))</span>
<span class="n">implicit_rule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">dso</span><span class="p">,</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">dso</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">lib</span><span class="p">))</span>
</pre></div>
</div>
<p>to register four implicit rules:</p>
<ul class="simple">
<li><p>one to build an object file from a C++ source file using a <cite>compile</cite> action</p></li>
<li><p>one to build a static library from one or more object files using an <cite>archive</cite> action</p></li>
<li><p>one to build a binary from object files, as well as shared and static libs using a <cite>link</cite> action</p></li>
<li><p>one to build a shared library from object files, as well as shared and static libs using a <cite>link</cite> action</p></li>
</ul>
</div>
<div class="section" id="composite-artefacts">
<h2>Composite artefacts</h2>
<p>In previous sections we dealt with artefacts that mostly correspond directly to
files, built by specific commands. While this model appeals through its simplicity,
it is not very portable: Most actions depend heavily on the platforms they are to be
executed on. Furthermore, depending on the platform / tools, different intermediate
artefacts may need to be built.</p>
<p>Let's consider again the case of a binary using a library. But instead of
referring explicitly to the library's file name (which may differ depending on the
platform, as well as whether or not it is compiled as a shared or a static library),
we use a composite artefact to encapsulate those details.
We use a new <cite>library</cite> rule to define it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">faber.artefacts.library</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">greet</span> <span class="o">=</span> <span class="n">library</span><span class="p">(</span><span class="s1">&#39;greet&#39;</span><span class="p">,</span> <span class="s1">&#39;greet.cpp&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <cite>library()</cite> call looks similar to the <cite>rule()</cite> call: xxx
<cite>artefact</cite> and a <cite>sources</cite> argument, and returns the artefact instance.
However, the artefact's name (<cite>greet.name</cite>) doesn't necessarily correspond
to the filename.
The precise build instructions are fully encapsulated inside the artefact,
and will take into account both the (target) platform as well as the tool and
features selected when the build was started.</p>
<p>Similarly, to use the library, you can pass <cite>greet</cite> as source to any dependent
rule or artefact, and the build logic will determine the precise action sequence
to use it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">faber.artefacts.binary</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">hello</span> <span class="o">=</span> <span class="n">binary</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;hello.cpp&#39;</span><span class="p">,</span> <span class="n">greet</span><span class="p">])</span>
</pre></div>
</div>
<p>Then, to build this with <cite>greet</cite> as shared library (<cite>.so</cite> on UNIX, <cite>.dll</cite> on
Windows), call <cite>faber link=shared</cite>. To build this as a static library
(<cite>.a</cite> on UNIX, <cite>.lib</cite> on Windows), use <cite>faber link=static</cite>.</p>
</div>
<div class="section" id="modular-builds">
<h2>Modular builds</h2>
<p>Once projects become large enough, it becomes useful to modularize the code as
well as the build instructions. Consider a case where we want to build a
library as well as a binary that is using that library. Both live in
separate directories:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">.../</span><span class="n">project</span><span class="o">/</span>
            <span class="n">subdir</span><span class="o">/</span>
                   <span class="n">greet</span><span class="o">.</span><span class="n">cpp</span>
                   <span class="n">fabscript</span>
            <span class="n">hello</span><span class="o">.</span><span class="n">cpp</span>
            <span class="n">fabscript</span>
</pre></div>
</div>
<p>The fabscript for the subproject is simply a stripped-down version of
our previous version, as it now only builds the <cite>greet</cite> library:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">faber.artefacts.library</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">greet</span> <span class="o">=</span> <span class="n">library</span><span class="p">(</span><span class="s1">&#39;greet&#39;</span><span class="p">,</span> <span class="s1">&#39;greet.cpp&#39;</span><span class="p">)</span>

<span class="n">default</span> <span class="o">=</span> <span class="n">greet</span>
</pre></div>
</div>
<p>The toplevel fabscript now includes that sub-project by virtue of a <a class="reference internal" href="../glossary.html#term-module"><span class="xref std std-term">module</span></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">faber.artefacts.binary</span> <span class="kn">import</span> <span class="n">binary</span>

<span class="n">subdir</span> <span class="o">=</span> <span class="n">module</span><span class="p">(</span><span class="s1">&#39;subdir&#39;</span><span class="p">)</span>

<span class="n">hello</span> <span class="o">=</span> <span class="n">binary</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;hello.cpp&#39;</span><span class="p">,</span> <span class="n">subdir</span><span class="o">.</span><span class="n">greet</span><span class="p">])</span>

<span class="n">rule</span><span class="p">(</span><span class="n">action</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">,</span> <span class="s1">&#39;$(&gt;)&#39;</span><span class="p">),</span> <span class="s1">&#39;test&#39;</span><span class="p">,</span> <span class="n">hello</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">notfile</span><span class="o">|</span><span class="n">always</span><span class="p">)</span>

<span class="n">default</span> <span class="o">=</span> <span class="n">hello</span>
</pre></div>
</div>
<p>Notice how the call to <cite>module('subdir')</cite> returns the module object,
through which we can access nested artefacts (and other variables).
The binary rule can now directly reference the <cite>subdir.greet</cite>
library as one of its sources, and the right thing will happen.</p>
</div>
</div>


    <div class="navbar" style="text-align:right;">
      
      
      <a class="prev" title="Basic concepts" href="basic_concepts.html"><img src="../_static/prev.png" alt="prev"/></a>
      <a class="up" title="Faber Tutorial" href="index.html"><img src="../_static/up.png" alt="up"/></a>
      <a class="next" title="Special Topics" href="special_topics.html"><img src="../_static/next.png" alt="next"/></a>
      
    </div>
    </div>
    <div class="footer">
      <p>last updated Dec 21, 2020</p>
    </div>
  </body>
</html>